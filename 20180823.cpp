#if 1
/*
농부 John은 최근 소 도서관을 위한 책꽂이를 구매했지만, 책이 빠른 속도로 채워져서 지금은 가장 윗부분에만 공간이 남아있다.
농부 John은 N마리의 소를 가지고 있다.(1 <= N <= 20) 각각의 소의 키는 H_i이다.(1 <= H_i<= 1,000,000)
책꽂이는 B 높이를 가지고 있다. (1 <= B <= S, S는 모든 소의 키의 합계임).
책꽂이의 제일 윗부분에 닿기 위해서, 하나 혹은 여러 마리의 소가 서로의 머리 위에 올라설 수 있다.
그래서 그들의 전체 높이는 개개인 소의 키의 합계가 된다. 소들이 책꽂이의 제일 윗부분에 닿기 위해서는 이 전체높이가 책꽂이 높이에 비해 낮아서는 안 된다.
소들이 서로의 머리 위에 올라서게 되면, 높으면 높을수록 위험해지기 때문에,
당신이 할 일은 책꽂이의 제일 윗부분에 닿을 수 있게 하는 소들의 키의 합의 최소값을 찾는 것이다.
당신의 프로그램은 당신이 찾게 된 소들의 키의 합이 책꽂이로부터 얼마나 초과하는지를 출력하면 된다.

입력
첫 번째 줄에는 테스트케이스의 갯수 T가 입력된다.
두 번째 줄부터 T개의 테스트케이스 세트가 주어진다.
테스트케이스의 첫번째 줄은 소의 마리수 N과 B가 주어진다. (1 <= N <= 20,1 <= B <= S, S는 모든 소의 키의 합계)
테스트케이스의 두번째 줄부터 N줄에 각 소의 키 H_i가 주어진다. (1 <= H_i<= 1,000,000)

출력
적당한 소들의 키의 합과 책꽂이 높이의 차이를 출력한다.

입력 예시
1
5 16
3
1
3
5
6

출력 예시
1

1. 파라미터
. pos : 몇번째 소인지...
. sum : 소들의 키에 대한 합

2. 리턴 : void(ok), int(x)
. 코스트 계산은 void로 함

3. 종료조건
. pos == N
1) 도시 1로 갈수 없으면 return 0
2) cost + 도시 1로 가는 비용 < sol
-> sol update
3) return

4. 가지치기
1)  
*/
#pragma warning (disable : 4996)
#include <stdio.h>

int T, N, B;
int H_i[20];
int sol = 0x7fffffff;

void DFS(int pos, int sum)
{
	int i;

	//1. 종료조건
	if (pos == N + 1) {
		sol = B - sum;
		return;;
	}

	for (i = 1; i <= N; i++) {
		if (sum + H_i[i] <= B) {
			DFS(pos + 1, sum + H_i[i]);
		}
	}



}

int main(void)
{
	int tc, i;
	// 여기서부터 작성
	scanf("%d", &T);
	for (tc = 1; tc <= T; tc++) {
		//주의 : 변수의 초기화 필요
		scanf("%d %d", &N, &B);

		for (i = 1; i <= N; i++) {

			scanf("%d", &H_i[i]);
		}
	}


	DFS(1, 0);
	printf("%d", sol);
	return 0;

}

#endif
#if 0
/*
문제를 잘 풀기로 소문난 도경이는 모든 올림피아드 대회에 참가하고 싶어 했다.
대회에 참가하여 상이란 상은 다 타고 싶은 마음이었지만, 한 가지 걸리는 것이 있었다.
문제는 올림피아드 대회가 모두 해외에서 열리는 관계로 비행기 값이 굉장히 많이 들어간다는 것이다.
결국에는 집으로 다시 돌아와야 하는데, 모든 대회에 1번씩만 참가하고 집으로 돌아오는
경비를 가장 최소화하고 싶다.도경이는 이것을 해결하지 못하면, 대회에 참가하기가 어렵게 된다.
대회는 참가하기만 하면 언제든지 알고리즘 문제를 풀 수 있기 때문에
경기를 계산하는 것 이외의 사항은 고려하지 않아도 된다.

입력
첫 줄은 참가하는 대회의 수 N(1≤N≤12)을 입력 받는다. 이때, 출발지(집)는 1번으로 한다.
둘째 줄은 N*N 크기의 대회 개최지와 개최지를 이동하는 항공료(0≤항공료<100)가 나온다.
각 항공료는 한 칸의 공백으로 구분된다. 만약에 개최지에서 개최지로 이동할 수 있는
항공로가 없다면 항공료의 값을 0으로 표시한다.

출력
집에서 출발하여 전체 대회를 모두 참가하고 돌아올 때, 최소의 항공료를 출력한다.

입력 예시
5
0 14 4 10 20
14 0 7 8 7
4 5 0 
7 16
11 7 9 0 2
18 7 17 4 0

출력 예시
30

도움말
예제의 비용 (경로)
10 (1->4)
+ 2 (4->5)
+ 7 (5->2)
+ 7 (2->3)
+ 4 (3->1)
= 30



1. 파라미터
 . pos : 방문할 도시의 순서
 . cost : pos 이전 도시까지의 비용
 . start : 출발 도시

2. 리턴 : void(ok), int(x)
 . 코스트 계산은 void로 함

3. 종료조건
 . pos == N
  1) 도시 1로 갈수 없으면 return 0
  2) cost + 도시 1로 가는 비용 < sol
     -> sol update
  3) return 

4. 가지치기
 1) 비행기가 있어야 한다. 0 아닌 값
 2) 이미 방문 했으면
 3) cost가 sol보다 크거나 같은 경우
*/
#pragma warning (disable : 4996)
#include <stdio.h>

int N;
int a[12 + 10][12 + 10];
int visit[12 + 10];
int sol = 0x7fffffff;

void DFS(int pos, int cost, int start) {
	//1. 종료 조건
	if (pos == N) {
		if (a[start][1] == 0) return; //1. 도시 1로 갈수 없으면 return (모두 돌았다고 하지만 1번 도시로 갈수 없으면... 종료)
		if (cost + a[start][1] < sol) {
			sol = cost + a[start][1];			
		}
		return;
	}

	int i;
	for (i = 2; i <= N; i++) {
		
		if (a[start][i] == 0) continue; //4-1. 가지치기 : 비행기가 없으면
		if (visit[i] == 1) continue; //4-2. 가지치기 : 이미 방문한 도시이면
		if (cost + a[start][i] >= sol) continue; //4-3. 가지치기 : cost + a[start][i] >= sol	


		//2. 재귀호출 1 : 선택하는 경우	
		visit[i] = 1; //전역변수 set
		DFS(pos + 1, cost + a[start][i], i);
		visit[i] = 0; //전역변수 복구
	}

	

	//2. 재귀호출 2 : 선택하지 않는 경우	
//	DFS(pos, cost, start);	
}

int main(void)
{
	// 여기서부터 작성
	int i, j;
	scanf("%d", &N);

	for (i = 1; i <= N; i++) {
		for (j = 1; j <= N; j++) {
			scanf("%d", &a[i][j]);
		}
	}

	DFS(1, 0, 1);
	printf("%d", sol);


	return 0;
}

#endif


#if 0
/*
N개의 노드로 구성된 그래프의 정보가 주어지고, 숫자 M이 주어진다. 이 때, 서로 인접한 노드들 간에는 같은 색을 칠하지 않으면서
M개의 색으로 N개의 노드를 전부 칠할 수 있는지 판단하라.
가능한 경우에는 첫 번째 노드부터 색상 번호(1 ~ M에서 선택)를 출력하고, 불가능한 경우 -1을 출력한다.
노드1부터 순서대로 색을 칠해야 하며 색상 번호도 낮은 번호부터 붙여 나가야 한다.  주어진 색상을 모두 사용할 필요는 없으며 가능하면
낮은 색상 번호를 사용하여 완성하라. 즉, 6개의 색이 주어졌어도 5개의 색으로 모두 칠할 수 있으면 5개색만 사용하여야 한다.
그래프 정보는 triangular matrix로 주어지고, 연결되어 있는 경우 1, 연결되어 있지 않은 경우 0으로 주어진다.

입력
첫 줄에 노드 수 N(1≤N≤12)와 색상 번호 M(1≤M≤12)가 주어진다.

출력
노드1부터의 칠해진 색상 번호 리스트를 출력한다.

불가능한 경우 -1을 출력한다.

입력 예시
4 3
0
1 0
1 1 0
0 1 1 0

출력 예시
1 2 3 1

1. 파라미터
 . pos : 노드 번호

2. 리턴 : void(x, 최대 최소값을 찾을때 사용), int(o)
 . 값을 발견하자 마자 끝내야 되서 int 0:실패, 1:성공

 3. 종료조건
  . pos == N+1 //끝까지 내려오면 끝이다, return 1;

4. 가지치기
 . 인접한 노드에 이미 칠해진 색상이면...

*/
#pragma warning (disable : 4996)

#include <stdio.h>

int N, M;
int a[12 + 10][12 + 10];
int c[12 + 10];

int check(int pos, int color) {
	///pos 위치에 colcr를 칠할수 있으면 1, 아니면 0
	int i;
	for (i = 1; i <= pos; i++) {
		//i는 이미 색상이 정해진 노드 번호
		//pos와 i가 연결되어 있고 같은 색상이면 return 0
		if (a[pos][i] == 1 && c[i] == color) return 0;
	}

	return 1;
}

int DFS(int pos)
{
	int i;
	//1. 종료조건
	if (pos == N + 1) return 1;

	//i는 칠할 색상
	for (i = 1; i <= M; i++) {		

		//2. 가지치기
		if (check(pos, i) == 0) continue;

		//전역변수 set
		c[pos] = i;
		//재귀호출
		if (DFS(pos + 1) == 1) return 1;
		//전역변수 복구
		c[pos] = 0;
	}
	return 0; //무조건
}

int main(void)
{
	// 여기서부터 작성
	int i, j;
	scanf("%d %d", &N, &M);

	for (i = 1; i <= N; i++) {
		for (j = 1; j <= i; j++) {
			scanf("%d", &a[i][j]);
			a[j][i] = a[i][j]; //대각선에 데칼코마니 형태로 값을 입력하기 위해
		}
	}
	
	if (DFS(1) == 1) {
		for (i = 1; i <= N; i++) {
			printf("%d ", c[i]);
	}
	}
	else printf("-1");	

	return 0;
}

#endif
#if 0
/*
소들은 농부 존의 농장을 탈출하는 대담한 계획을 세웠다. 그들은 작은 고무 보트를 구했고 한 밤중에 농장 경계에 흐르는 강을 보트를 타고 건너려는 계획이다.
그 계획은 완벽해 보였다. 작은 고무 보트가 소들의 무게를 견디지 못한다는 사실을 알기 전까지는…
N마리의 소(1≤N≤20)들의 무게는 각각 W_1, …, W_N이다. 보트가 침몰하지 않을 만큼 가벼운 소들을 선별해야 한다.
불행하게도, 소들은 산수를 못하기로 유명하다. 10진법을 사용하는 소들은 소들의 무게를 더하다가 자리올림이 발생하는 경우
그 소는 보트를 사용하기에는 너무 무거운 소라고 판단한다. 자리올림이 발생하지 않고 더할 수 있는 무게가 보트를 사용할 수 있는 가벼운 무게이다.
당신이 할 일은 소들을 도와서 보트를 탈 수 있는 소들의 최대 수를 구하는 것이다.
즉, 소들의 무게들을 모두 더했을 때 자리올림이 발생하지 않게 하는 소들의 최대 수를 구하는 것이다.

입력
첫 줄에 소들의 수 N(1≤N≤20)이 주어진다.
두 번째 줄부터 N 줄에 걸쳐 각 소의 무게(W_i)가 입력된다. (정수, 1≤W_i≤100,000,000)

출력
무게를 모두 더했을 때 어떤 자리에서도 자리올림이 발생하지 않는 소들의 최대 수를 출력하라.

입력 예시
5
522
6
84
7311
19

출력 예시
3

도움말
522 + 6 + 7311 = 7839, 세 마리 소의 무게를 더할 때 어떤 자리에서도 자리올림이 발생하지 않는다.
522
6
+ 7311
---------
7839


1. 파라미터
 pos -> 배에 실을 소의 번호
 sum -> pos 이전까지의 소 무게합
 cnt -> pos 이전까지의 소의 마리수

 2. 리턴 : void(ok), int(x)
 3. 종료 조건
  . pos == N+1 //전부다 돌아야지
  . cnt 참조해서 sol 업데이트 후 return
4. 가지치기
 . 소를 선택해서 더했을때 자리넘침이 발생할때
 .
*/


#pragma warning (disable : 4996)

#include <stdio.h>

int N;
int W_i[20 + 10];
int sol;

int check(int x, int y) {
	//자리 넘침이 발생시 0, 아니면 1 리턴
	//1의 자리 x % 10 + y % 10
	//10의 자리 x /10%10 + y/10%10
	//100의 자리 x/100%10 + y/100%10
	//100000000	
	while (x > 0 && y>0) {	

		if ((x % 10 + y % 10) >= 10) return 0;
		x /= 10;
		y /= 10;
	}	
	
	return 1;
}


void DFS(int pos, int sum, int cnt) {
	//1. 종료 조건
	

	if (pos == N + 1)
	{
		if (cnt > sol) {
			sol = cnt;			
		}
		return;
	}

	//2. 재귀호출 1 : 선택하는 경우	
	if (check(sum, W_i[pos]) == 1) { //4. 가지치기 1	
		DFS(pos + 1, sum + W_i[pos], cnt + 1);
	}
	

	//3. 재귀호출 2 : 선택하지 않는 경우
	DFS(pos + 1, sum, cnt);	

}

int main(void)
{
	// 여기서부터 작성
	int i;
	scanf("%d", &N);
	for (i = 1; i <= N; i++) {
		scanf("%d", &W_i[i]);
	}

	DFS(1, 0, 0);

	printf("%d", sol);

	return 0;
}

#endif

#if 0 
/*
덧셈을 못하는 철수를 공부시키기 위해 자연수들을 주고, 그 중에 몇 개의 수를 골라서 그 합이 K가 될 수 있는지 알아보라고 시켰다.
철수 어머니가 자연수들을 무작위로 선택해서 본인도 가능한지 아닌지 모르고 있다.
어머니가 채점을 할 수 있게 주어진 문제의 답을 찾아주자.

입력
첫 번째 줄에 테스트 케이스 개수 T(1≤T≤10)가 주어진다.
두 번째 줄부터 아래 내용이 T개 만큼 주어진다.
첫 줄에 자연수 개수 N(5 <= N <= 20)과 K(1 <= K <= 2,000,000)가 공백으로 구분되어 입력된다.
다음 줄에 N개의 자연수 di(1 <= di <= 100,000)가 공백으로 구분되어 입력된다.

출력
T줄에 걸쳐 각 테스트 케이스 별로 주어진 자연수 중 몇 개의 합이 K가 되면 “YES”를 아니면 “NO”를 출력한다.

입력 예시
2
5 19
1 2 4 7 10
5 25
1 2 4 7 10


출력 예시
YES
NO

//DFS함수 설계 비법
STEP 0. 그림 그리기
STEP 1. 그림에 근거해서 함수의 파라미터 선정(DFS함수에 넘겨줄 값들, ex) pos : 사용할 숫자의 위치, depth, h, sum : pos 이전까지의 값)
STEP 2. 리턴
   ㄱ. void : 완전히 탐색해야 답이 나옴. 
   ㄴ. int : 돌아다니다가 중간에 답이 나옴.
   ex) int DFS(int pos, int sum)
STEP 3. 종료 조건
   ㄱ. sum == k(주어진 값) -> return 1;
   ㄴ. pos == N+1 -> return 0;
STEP 4. 가지치기(필요 없는 것들 없애기)
   ㄱ. sum > k :  sum의 값이 k(주어진 값) 보다 클 경우 더이상 값이 나올수 없으니 찾을 필요가 없다
*/
#pragma warning (disable : 4996)

#include <stdio.h>

int T, N, K;
int a[20 + 10];

int DFS(int pos, int sum)
{
	//step 4. 가지치기 B
	//if (sum > K) return 0;
	//step 3. 종료조건
	if (sum == K) return 1;
	if (pos == N + 1) return 0;

	//step 4. 가지치기 A
	if (sum + a[pos] <= K) {
		//재귀호출 1: 선택하는 경우
		if (DFS(pos + 1, sum + a[pos]) == 1) return 1;
	}
	//재귀호출 2 : 선택하지 않는 경우
	if (DFS(pos + 1, sum) == 1) return 1;

	return 0; //무조건
}


int main(void)
{
	// 입력받는 부분
	int tc, i;
	scanf("%d", &T);

	// 여기서부터 작성
	for (tc = 1; tc <= T; tc++) {
		scanf("%d %d", &N, &K);
		for (i = 1; i <= N; i++) {
			scanf("%d", &a[i]);
		}
		// 출력하는 부분
		if (DFS(1, 0) == 1) printf("YES\n");
		else printf("NO\n");
	}
	
	return 0;

}

#endif


#if 0 
/*
한 정수 n을 입력 받아서 1부터 n까지의 합을 구하여 출력하시오.
단, 반드시 재귀함수로 구현하시오.

입력
입력은 키보드로부터 이루어진다.
정수 n(2 ≤ n ≤ 10,000)이 첫 번째 줄에 입력된다.

출력
1~n까지의 합을 한 정수로 출력하시오.

입력 예시
10

출력 예시
55
*/
#pragma warning (disable : 4996)

#include <stdio.h>

int N;
int sol;

int add(int num)
{
	if (num == 1) return 1;
	else return num + add(num - 1);
}

int main(void)
{
	// 입력받는 부분
	scanf("%d", &N);

	// 여기서부터 작성
	sol = add(N);

	// 출력하는 부분
	printf("%d", sol);
	return 0;

}

#endif